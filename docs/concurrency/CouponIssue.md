# 🎯 선착순 쿠폰 발급 트랜잭션 동시성 처리 전략

## 📌 개요

선착순으로 제한된 수량의 쿠폰을 사용자에게 발급하는 과정에서 **동시성 이슈**를 해결하기 위한 트랜잭션 처리 전략을 설계한다.

---

## 📂 대상 테이블

- `COUPON`
    - `coupon_id` (PK)
    - `remaining_coupon_amount` (잔여 쿠폰 수량)

---

## 📎 처리 쿼리

```sql
UPDATE COUPON
SET remaining_coupon_amount = ?
WHERE coupon_id = ?;
```

## 📈 동시성 시나리오

### ✅ 정상 시나리오

- **총 쿠폰 수량**: 30개
- **요청 사용자 수**: 20명
- → **20명 모두 발급 성공**, 잔여 10개

### ❗ 경합 시나리오

- **총 쿠폰 수량**: 30개
- **요청 사용자 수**: 100명
- → **30명만 성공**, **나머지 70명은 실패해야 함**

---

## ⚙️ 트랜잭션 처리 조건

- 사용자는 **최초 1회 요청만** 보내도 잔여 수량이 있다면 **성공적으로 발급**되어야 한다.
- 재시도 요청 없이도 **정확한 수량만큼만 발급**되어야 하며, **과발급은 절대 불가**.

---

## 🔐 DB Lock 전략

### 선택: **비관적 락 (Pessimistic Lock)**

```java
// JPA Repository
@Lock(LockModeType.PESSIMISTIC_WRITE)
Coupon findByCouponId(Long couponId);
```

---

## 📌 비관적 락 적용 이유

| 항목 | 설명 |
| --- | --- |
| 🔁 트랜잭션 단위 | 매우 짧음 (단일 update) |
| 🔐 락 필요 이유 | 잔여 쿠폰 수량 확인과 동시에 락을 걸어 **정합성 유지** |
| ⚠️ 낙관적 락의 한계 | 동시 요청 100건 시, 1건 성공 + 99건 실패 → 재시도 유도 → DB 부하 증가 |
| 🎯 비관적 락 장점 | 경합 시 대기 상태 진입 → 순차적으로 처리 가능 → **재시도 없이 안정적 발급 처리 가능** |
| 🚫 실패 방지 | 잔여 수량 있음에도 충돌로 인해 발급 실패하는 **불합리한 상황 방지** |

---

## ✅ 결론

- **비관적 락**을 통한 동시성 제어는 **선착순 쿠폰 발급 시 가장 안정적인 방식**이다.
- 낙관적 락 기반의 충돌-재시도 방식은 **재시도 로직 필요 및 DB 부하 유발**로 인해 적합하지 않다.
- 락으로 인한 **대기 상태**는 짧은 트랜잭션으로 인해 충분히 감내할 수 있는 수준이며, **데이터 정합성 보장**이라는 측면에서 **우선 고려되어야 한다**.