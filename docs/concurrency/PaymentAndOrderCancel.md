# 💥 결제 vs 주문 취소 - 트랜잭션 동시성 처리 전략

## 📌 개요

결제 및 주문 취소는 **동일한 주문(ORDER)**에 대해 서로 다른 트랜잭션이 처리되는 시나리오로, 동시에 요청이 들어올 경우 **데이터 정합성에 중대한 영향을 줄 수 있는 동시성 이슈**가 존재한다.

본 문서에서는 이러한 충돌을 방지하기 위해 **낙관적 락 기반의 제어 전략**을 정의한다.

---

## 📂 프로세스 정의

### 🟢 결제

```
[잔액 사용 → 주문 상태 변경 → 결제 정보 저장]

BALANCE: 결제 금액만큼 차감
ORDER: 주문 상태를 PAID 등으로 변경
PAYMENT: 결제 내역 저장 (INSERT)
```

### 🔴 주문 취소

```
[쿠폰 복구 -> 재고 복구(N개 상품 옵션) → 주문 상태 변경]

COUPON_ISSUED_INFO: 쿠폰 복구
PRODUCT_OPTION: 재고 복구
ORDER: 주문 상태를 CANCELED 등으로 변경
```

## 📎 업데이트 대상 테이블

| 프로세스 | 대상 테이블 |
| --- | --- |
| 결제 | `BALANCE`, `ORDER`, `PAYMENT(insert)` |
| 주문 취소 | `COUPON_ISSUED_INFO`, `PRODUCT_OPTION`, `ORDER` |

---

## ⚠️ 동시성 시나리오 분석

### 잠재적인 충돌 시나리오

| 시나리오 | 문제점 |
| --- | --- |
| 결제 요청 처리 → 주문 취소 요청 처리 | - 결제 완료 상태인데 재고/쿠폰이 복구됨- 잔액 차감은 남아 있음 (환불 안됨) |
| 주문 취소 요청 처리 → 결제 요청 처리 | - 주문은 이미 취소되었는데 결제는 완료됨- 무효 주문에 결제 정보가 남음 |

### 결론

- 두 요청이 **모두 처리되면 정합성 문제가 발생**
- 반드시 **하나의 트랜잭션만 성공하고, 나머지는 실패 처리**되어야 함

---

## 🔐 DB Lock 전략

| 대상 테이블 | 락 방식 | 적용 쿼리 예시 |
| --- | --- | --- |
| `ORDER` | **낙관적 락 (Optimistic Lock)** | `@Version` 컬럼 활용 (JPA 등) |

```java
// JPA Repository 예시
@Lock(LockModeType.OPTIMISTIC)
Order findByOrderId(Long orderId);
```

- `ORDER` 테이블에 `version` 필드를 추가하고, update 시 해당 버전 조건으로 동시성 제어 수행

---

## ✅ 이유 및 설계 근거

| 항목 | 설명 |
| --- | --- |
| 🔁 충돌 가능성 | 동일한 주문 건에 대해 결제와 취소가 **거의 동시에 요청될 수 있음** |
| 🚫 동시 처리 문제 | 두 요청이 모두 처리되면 **잔액, 재고, 쿠폰** 정합성 붕괴 |
| 🧩 처리 방식 차이 | 같은 테이블을 수정하지만, **비즈니스 로직이 상이하므로 상호 양립 불가** |
| 🔄 낙관적 락 적합성 | 충돌 시점에 하나의 요청만 update 성공, 나머지는 실패 처리 가능 |
| ✅ 실패 처리 허용 | 실패 시 재시도 또는 사용자 안내를 통해 처리 가능 |
| ⚖️ 비관적 락은 왜 아닌가? | 불필요한 락 경합, 락 대기, 트랜잭션 지연 가능성이 높음
주문마다 단건 처리이므로 낙관적 락이 더 효율적 |

---

## 🏁 결론

- 결제와 주문 취소는 같은 주문 데이터를 갱신하지만, **논리적으로 상충되는 처리**를 수행한다.
- 이로 인해, 동시 요청 시 반드시 **하나의 트랜잭션만 성공 처리되어야 하며**, 나머지는 **낙관적 락 실패를 통해 에러 처리**되어야 한다.
- `ORDER` 테이블에 `version` 기반의 **낙관적 락을 적용**함으로써 정합성을 유지하고, **데이터 충돌에 대한 안전한 보호 장치**를 마련할 수 있다.