# 💳 결제 vs 잔액 충전 - 트랜잭션 동시성 처리 전략

## 📌 개요

결제 및 잔액 충전 기능은 모두 사용자의 **BALANCE** 테이블을 갱신하는 작업이 포함되며, **동시성 제어가 필수적인 핵심 영역**이다. 본 문서에서는 결제/충전 시 발생할 수 있는 **정합성 이슈**를 방지하기 위한 DB Lock 전략을 정의한다.

---

## 📂 프로세스 정의

### 🟢 결제 (사용)

```
[잔액 사용 → 주문 상태 변경 → 결제 저장]

BALANCE: 결제 금액만큼 차감
ORDER: 결제 완료 상태로 업데이트
PAYMENT: 결제 정보 저장 (INSERT)
```

### 🟡 잔액 충전

```
[잔액 충전]

BALANCE: 충전 금액만큼 증가
```

---

## 📎 업데이트 대상 테이블

| 프로세스 | 대상 테이블 |
| --- | --- |
| 결제 | `BALANCE`, `ORDER`, `PAYMENT` |
| 충전 | `BALANCE` |

---

## ⚠️ 동시성 시나리오 분석

### 예시 상황

- 초기 잔액: **1,000원**

| 시나리오 | 결과 기대 잔액 | 이슈 가능성   |
| --- | --- |----------|
| A. 10,000원 충전 + 5,000원 사용 | `6,000원` | 충돌 가능    |
| B. 5,000원 사용 + 10,000원 충전 | `11,000원` | 충돌 가능    |
| C. 1,000원 충전 * 100회 | `100,000원` | 반복 충돌 가능 |
| D. 1,000원 사용 * 100회 (110,000원 보유 상태) | `10,000원` | 반복 충돌 가능 |

### 결론

- 충전 및 사용이 동시에 발생하면 **잔액 갱신 시 update 손실이 발생할 수 있음**
- 모든 충전/사용 요청은 **정상 처리**되어야 하며, 재시도나 실패 없이 순차적으로 처리되어야 함

---

## 🔐 DB Lock 전략

| 대상 테이블 | 락 방식 | 적용 쿼리 예시 |
| --- | --- | --- |
| `BALANCE` | **비관적 락 (Pessimistic Lock)** | `SELECT * FROM balance WHERE user_id = ? FOR UPDATE` |

```java
// JPA Repository 예시
@Lock(LockModeType.PESSIMISTIC_WRITE)
Balance findByUserId(Long userId);
```

---

## ✅ 이유 및 설계 근거

| 항목 | 설명 |
| --- | --- |
| 🔁 트랜잭션 단위 | 충전/사용 모두 단일 비관적락 update이므로 **락 점유 시간이 짧음** |
| 🧑 사용자 별 처리 | 사용자 단위로 구분되어 **접근 경합도 낮음**, 조회 성능 저하 없음 |
| 💥 동시 update 방지 | 잔액이 동시에 갱신될 경우, **정합성 오류 (누락 or 덮어쓰기)** 발생 가능 |
| ⚠️ 낙관적 락의 한계 | 충돌 시 단순 에러 리턴 외에 **정상 처리 보장 어려움**, 재시도 로직 필요 |
| ✅ 비관적 락 장점 | 충돌 시 대기 처리되어 모든 요청이 **순차적이고 정확하게 반영**됨 |

---

## 🏁 결론

- `BALANCE` 테이블에 대해서는 **비관적 락을 적용**하는 것이 가장 신뢰성 높은 전략이다.
- 사용자 단위로 트랜잭션이 분리되어 있어 락 경합 가능성이 낮고, 트랜잭션 단위도 작아 **성능 부담이 거의 없다**.
- 낙관적 락은 에러 처리와 재시도 로직이 추가로 필요하며, 이 경우에는 오히려 **시스템 복잡도를 증가**시킬 수 있다.
- **결제 및 충전 모두 중요한 금액과 관련된 트랜잭션이므로**, 실패 없는 정합성 보장을 위해 **비관적 락을 적극 활용해야 한다**.