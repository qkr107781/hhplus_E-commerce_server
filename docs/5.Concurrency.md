## **✅ 동시성 이슈로 인해 발생할 수 있는 DB 이슈**

---

### **1. Lost Update (갱신 손실)**

- 두 트랜잭션이 같은 데이터를 수정하고, 한 쪽의 결과가 덮어써짐.
- 결과적으로 한 트랜잭션의 변경이 사라짐.
- 무결성 문제 발생.

📌 예: 재고 감소를 두 사용자가 동시에 시도하면 한 쪽만 반영되는 경우

---

### **2. Uncommitted Dependency (커밋되지 않은 의존)**

- 트랜잭션 실행 중 문제가 발생해 롤백시키면서 반영되지 않아야 할 데이터를 읽는 문제
- 반영되지 않은 데이터를 읽어 잘못된 정보를 표출하게 됨.

📌 예: 트랜잭션 A가 재고를 수정하고 B가 그 값을 읽었는데 A가 롤백하면? B는 잘못된 재고를 본 것임.

---

### **3. Inconsistency Analysis (모순 감지)**

- 트랜잭션 실행 중에 다른 트랜잭션이 데이터 수정에 개입해 데이터 일관성이 깨지는 문제

📌 예: 트랜잭션 A가 사용자에게 3건의 잔액 충전을 일괄 처리 중인데, 중간에 트랜잭션 B가 개입해 사용자의 잔액을 조회하여 결제를 시도함. 트랜잭션 A는 아직 충전 내역을 모두 반영하지 않은 상태라, 트랜잭션 B는 부정확한 잔액을 기반으로 결제를 시도하게 됨. → 일관성 깨짐.

---

### **4. Non-repeatable Read (비반복 읽기)**

- 같은 SELECT를 두 번 했는데 결과가 다름.
- 사이에 다른 트랜잭션이 데이터를 수정했기 때문.

📌 예: 첫 번째 select에서 재고가 10이었는데 두 번째 select에서는 11로 바뀜.

---

### **5. Phantom Read (팬텀 읽기)**

- 같은 조건으로 SELECT 했는데 레코드 수가 다름.
- 사이에 다른 트랜잭션이 새로운 데이터를 INSERT 또는 DELETE함.

📌 예: `WHERE age > 30`으로 조회했는데, 중간에 누가 age 31인 사람을 넣어서 다시 조회했더니 결과가 달라짐.

---

### **6. Deadlock (교착 상태)**

- 두 개 이상의 트랜잭션이 서로가 필요한 자원을 가지고 무한 대기하는 상태.
- 시스템이 자동으로 하나를 죽여야 함 (롤백됨).

📌 예: A가 X를, B가 Y를 잠그고 각각 Y와 X를 요구할 때

---

### **7. Lock Timeout (락 타임아웃)**

- 트랜잭션이 다른 트랜잭션의 락을 오랫동안 기다리다가 시간 초과로 실패하는 경우.

📌 예: 사용자 A가 긴 트랜잭션으로 데이터를 잠그고 있어서 사용자 B의 요청이 계속 지연됨 → 결국 실패

---

### **8. 데이터 무결성 손상**

- 위 이슈들이 복합적으로 작용하면 데이터가 실제로 신뢰할 수 없는 상태가 될 수 있음.
- 예: 중복 주문, 재고 마이너스, 잔액 이상 등

---

### **9. 성능 저하**

- 락 경쟁(lock contention), 데드락 회피, 격리 수준 증가 등으로 인해 트랜잭션 처리 속도 감소
- 대기 시간 증가 → 사용자 체감 지연

---

## **💡 요약**

| **이슈** | **설명** | **결과** |
| --- | --- | --- |
| Lost Update | 변경이 덮어씀 | 데이터 손실 |
| Uncommitted Dependency | 커밋되지 않은 값 읽음 | 잘못된 데이터 읽어옴 -> 읽어서 처리하게 되면 문제 발생 |
| Inconsistency Analysis | 타 트랙재션에 개입 | 데이터 일관성 깨짐 |
| Non-repeatable Read | 같은 쿼리 결과 다름 | 예측 불가능한 동작 |
| Phantom Read | 레코드 수 변동 | 결과 불일치 |
| Deadlock | 트랜잭션 간 무한 대기 | 시스템 자동 롤백 |
| Lock Timeout | 락 대기 시간 초과 | 트랜잭션 실패 |
| 데이터 무결성 손상 | 논리적으로 오류 생김 | 시스템 신뢰성 저하 |
| 성능 저하 | 트랜잭션 지연 | 사용자 경험 악화 |

## 트랜잭션 동시성 처리 전략

<details>

<summary><h2>🎟️ 선착순 쿠폰 발급</h2></summary>

## 📌 개요

선착순으로 제한된 수량의 쿠폰을 사용자에게 발급할 때, **동시성 이슈**를 방지하여 **정확한 수량만큼만 발급되도록** 동시성 처리 전략을 정의한다.

---

## 🔄 프로세스

```
[잔여 수량 확인 → 수량 차감 → 쿠폰 발급]
```

---

## 🗂️ 대상 테이블

| 프로세스 | 대상 테이블 |
| --- | --- |
| 잔여 수량 확인 | `COUPON` |
| 수량 차감 | `COUPON` |
| 쿠폰 발급 | `COUPON_ISSUED_INFO(insert)` |

---

## ⚠️ 동시성 시나리오 분석

| 시나리오 | 기대 동작 |
| --- | --- |
| 발급 제한 갯수 내 요청 | 총 100개, 20명 요청 → 20명 발급, 80개 남음 |
| 발급 제한 갯수 초과 요청 | 총 100개, 200명 요청 → 100명 발급, 100명 실패 |

---

## 🔐 Lock 전략

| 대상 | Lock 전략 | 처리 방식 |
| --- | --- | --- |
| `COUPON` | 비관적 락 (`PESSIMISTIC_WRITE`) | 충돌 시 대기 → 순차 처리 → 초과 발급 방지 |

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
Coupon findById(Long couponId);
```

---

## 🧩 설계 근거

| 항목 | 설명 |
| --- | --- |
| 🔁 트랜잭션 단위 | 매우 짧음 (단일 update), 락 점유 시간 매우 짧음 |
| 🔐 락 필요 이유 | 잔여 쿠폰 수량 확인과 동시에 락을 걸어 **정합성 유지 → 초과 발급 방지** |
| ⚠️ 낙관적 락의 한계 | 동시 요청 100건 시, 1건 성공 + 99건 실패 → 재시도 유도 → DB 부하 증가 |
| 🎯 비관적 락 장점 | 경합 시 대기 상태 진입 → 순차적으로 처리 가능 → **재시도 없이 안정적 발급 처리 가능** |
| 🚫 실패 방지 | 잔여 수량 있음에도 충돌로 인해 발급 실패하는 **불합리한 상황 방지** |

---

## ✅ 결론

- **비관적 락**을 통해 **정확한 수량만 발급**되고, 초**과 발급 없이 정합성 보장** 가능
- 낙관적 락 기반의 충돌-재시도 방식은 **재시도 로직 필요 및 DB 부하 유발**로 인해 적합하지 않다.
- 트랜잭션이 짧고, 경합 시에도 안정적으로 동작함
- 락으로 인한 **대기 상태**는 짧은 트랜잭션으로 인해 충분히 감내할 수 있는 수준이며, **데이터 정합성 보장**이라는 측면에서 **우선 고려되어야 한다**.

</details>

<details>

<summary><h2>🛒 주문 생성 vs 주문 취소</h2></summary>

## 📌 개요

주문 생성 및 주문 취소 시 발생할 수 있는 동시성 이슈를 고려하여, **재고 및 쿠폰 처리의 락 전략**을 정의하고, **데드락 방지 및 정합성 유지**를 위한 설계 방향을 문서화한다.

---

## 🔄 프로세스

### 🟢 주문 생성

```
[재고 차감(N번 실행) → 쿠폰 사용(최대 1개) → 주문 생성]
```

### 🔴 주문 취소

```
[재고 복구(N번 실행) → 쿠폰 복구 → 주문 상태 변경]
```

---

## 🗂️ 대상 테이블

| 프로세스 | 대상 테이블(내부 프로세스 순서대로) |
| --- | --- |
| 주문 생성 | `PRODUCT_OPTION`, `COUPON_ISSUED_INFO`, `ORDER(insert)` |
| 주문 취소 | `PRODUCT_OPTION`, `COUPON_ISSUED_INFO`, `ORDER` |

---

## ⚠️ 동시성 시나리오 분석

| 시나리오 | 기대 동작 |
| --- | --- |
| 재고 반복 차감 | 재고 30개 → 차감 요청 2개 → 차감 요청 3개 → 재고 25개 → …. → 재고 0개 → 차감 불가 |
| 재고 반복 복구(최대 30개) | 재고 5개 →  복구 요청 2개 → 복구 요청 3개 → 재고 10개 → … → 재고 30개 → 복구 불가 |
| 재고 차감/복구 | 재고 10개 → 재고 차감 요청 → 재고 복구 요청 → 재고 10개 |

---

## ⚠️ 데드락 방지 설계

### 시나리오

- 사용자 A가 주문 생성: **상품 옵션 ID 1, 2** → 재고 차감 시도
- 사용자 B가 주문 취소: **상품 옵션 ID 2, 1** → 재고 복구 시도

```
A: SELECT ... WHERE product_option_id = 1 → LOCK
B: SELECT ... WHERE product_option_id = 2 → LOCK
A: SELECT ... WHERE product_option_id = 2 → BLOCK
B: SELECT ... WHERE product_option_id = 1 → BLOCK → 💥 데드락 발생 가능
```

### 해결 방법

- **재고 차감 시, 입력된 상품 옵션을 항상 동일한 기준(오름차순)으로 정렬**(예: `orderRequest.productOptionIds().stream().sorted().collect(Collectors.*toList*());`)
- **재고 복구 시, 항상 동일한 정렬 기준(오름차순)으로 주문 상품 SELECT** (예: `ORDER_PRODUCT - product_option_id ASC`)
- 모든 주문 상품을 **선 정렬 후 상품 옵션을 FOR UPDATE**로 조회하여 락 획득 순서를 통일
- 재고 복구 예시 쿼리:

```sql
#주문에 포함된 모든 상품 옵션 조회
SELECT * FROM order_product
WHERE order_id = ? 
ORDER BY product_option_id ASC;

#위에서 조회한 상품 옵션 단건 조회
SELECT * FROM product_option
WHERE product_option_id = ?
FOR UPDATE;
```

---

## 🔐 Lock 전략

| 대상 | Lock 전략 | 처리 방식 |
| --- | --- | --- |
| `PRODUCT_OPTION` | **비관적 락** (`FOR UPDATE`) | 충돌 시 대기 → 순차 처리 → 차감/복구 미처리 방지 |
| `COUPON_ISSUED_INFO` | 일반 처리 (update) |  사용자에게 중복없이 종속되는 데이터라 충돌 없음 |
| `ORDER` | 일반 처리 (Insert / Update) | 생성 or 상태 변경, 충돌 없음 |

```jsx
@Lock(LockModeType.PESSIMISTIC_WRITE)
ProductOption findById(Long productOptionId);
```

---

## 🧩 설계 근거

### 📦 재고 (PRODUCT_OPTION)

- **공유 자원**이며 동시 접근이 빈번하게 발생
- 과차감이 발생하면 재고 오류로 비즈니스 치명타
- **비관적 락을 사용하여 동시에 접근한 트랜잭션은 대기 처리**
- 트랜잭션 중 데드락 방지를 위해 **항상 정렬된 순서로 조회**

### 🎟️ 쿠폰 (COUPON_ISSUED_INFO)

- 주문 당 쿠폰 최대 1개 사용 가능
- coupon_id + user_id 유니크키로 설정하여 쿠폰 중복 소유 불가 → 사용할 쿠폰은 사용자에게 종속된 데이터 row
- 생성되지 않은 주문은 취소 자체가 불가 하기에 동일 사용자의 생성/취소 두 개의 요청은 동시성 이슈가 없음
- 충돌 가능성 없고, 락 불필요

### 📃 주문 (ORDER)

- 새로 생성되거나 상태만 변경되는 데이터
- 충돌 가능성 없고, 락 불필요

---

## ✅ 결론

- **재고는 비관적 락**이 가장 합리적이며 현실적인 동시성 제어 방식이다.
- 재고 조회 시에는 항상 정렬 기준을 명확히 하여 데드락을 **사전에 방지**해야 한다.
- 이러한 구조는 충돌 시 대기 후 순차처리되어 **데이터 정합성을 유지할 수 있는 방식이다**

</details>

<details>

<summary><h2>💳 결제 vs 잔액 충전</h2></summary>

## 📌 개요

결제 및 잔액 충전 기능은 모두 사용자 잔액 (**BALANCE** 테이블)을 갱신하는 작업이 포함되며, **동시성 제어가 필수적인 핵심 영역**이다. 본 문서에서는 결제/충전 시 발생할 수 있는 **정합성 이슈**를 방지하기 위한 DB Lock 전략을 정의한다.

---

## 📂 프로세스 정의

### 🟢 결제 (사용)

```
[주문 상태 변경 → 잔액 차감 → 결제 정보 저장]
```

### 🟡 잔액 충전

```
[잔액 증가]
```

---

## 🗂️ 대상 테이블

| 프로세스 | 대상 테이블(내부 프로세스 순서대로) |
| --- | --- |
| 결제 | `ORDER`, `BALANCE`, `PAYMENT`(insert) |
| 충전 | `BALANCE` |

---

## ⚠️ 동시성 시나리오

| 시나리오 | 기대 동작 |
| --- | --- |
| 충전 + 결제 동시 처리 | 잔액 400,000원 → 충전 10,000원 → 결제 319,000원 → 잔액 91,000원 |
| 반복 충전 | 충전 1,000원 → .…(98번)…. → 충전 1,000원 → 잔액 100,000원 |
| 반복 결제(여러건의 주문 대상) | 잔액 101,000 → 결제 1,000원 → .…(98번)…. → 결제 1,000원 → 잔액 1,000원 |

---

## 🔐 Lock 전략

| 대상 | Lock 전략 | 처리 방식 |
| --- | --- | --- |
| `BALANCE` | 비관적 락 (`FOR UPDATE`) | 충돌 시 대기 → 순차 처리 → 초과 충전/초과 복구 방지 |

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT b FROM Balance b WHERE b.userId = :userId")
Balance findByUserIdForUpdate(@Param("userId") long userId);
//기존 조회 쿼리와 공용으로 쓸 수 없어 JPQL사용
```

---

## 🧩 설계 근거

| 항목 | 설명 |
| --- | --- |
| 🔁 트랜잭션 단위 | 충전/사용 모두 단일 비관적락 update이므로 **락 점유 시간이 짧음** |
| 🧑 사용자 별 처리 | 사용자 단위로 구분되어 **접근 경합도 낮음**, 조회 성능 저하 없음 |
| 💥 동시 update 방지 | 잔액이 동시에 갱신될 경우, **정합성 오류 (누락 or 덮어쓰기)** 발생 가능 |
| ⚠️ 낙관적 락의 한계 | 충돌 시 단순 에러 리턴 외에 **정상 처리 보장 어려움**, 재시도 로직 필요 |
| ✅ 비관적 락 장점 | 충돌 시 대기 처리되어 모든 요청이 **순차적이고 정확하게 반영**됨 |

---

## ✅ 결론

- `BALANCE` 테이블에 대해서는 **비관적 락을 적용**하는 것이 가장 신뢰성 높은 전략이다.
- 사용자 단위로 트랜잭션이 분리되어 있어 락 경합 가능성이 낮고, 트랜잭션 단위도 작아 **성능 부담이 거의 없다**.
- 낙관적 락은 에러 처리와 재시도 로직이 추가로 필요하며, 이 경우에는 오히려 **시스템 복잡도를 증가**시킬 수 있다.
- **결제 및 충전 모두 중요한 금액과 관련된 트랜잭션이므로**, 실패 없는 정합성 보장을 위해 **비관적 락을 적극 활용해야 한다**.

</details>

<details>

<summary><h2>💥 결제 vs 주문 취소</h2></summary>

## 📌 개요

결제 및 주문 취소는 **동일한 주문**에 대해 서로 다른 트랜잭션이 처리되는 시나리오로, 동일한 주문에 대해 **상충되는 처리를 수행**하므로, 동시에 요청이 들어올 경우 **데이터 정합성에 중대한 영향을 줄 수 있는 동시성 이슈**가 존재한다.

본 문서에서는 이러한 충돌을 방지하기 위해 **낙관적 락 기반의 제어 전략**을 정의한다.

---

## 🔄 프로세스 정의

### 🟢 결제

```
[주문 상태 변경 → 잔액 차감 → 결제 정보 저장]
```

### 🔴 주문 취소

```
[재고 복구(N번 실행) -> 쿠폰 복구 -> 주문 상태 변경]
```

## 🗂️ 대상 테이블

| 프로세스 | 대상 테이블(내부 프로세스 순서대로) |
| --- | --- |
| 결제 | `ORDER`, `BALANCE`, `PAYMENT(insert)` |
| 주문 취소 | `PRODUCT_OPTION`, `COUPON_ISSUED_INFO`, `ORDER` |

---

## ⚠️ 동시성 시나리오

### 잠재적인 충돌 시나리오

| 시나리오 | 문제점 |
| --- | --- |
| 동일 주문에 대한 결제 요청 처리 → 주문 취소 요청 처리 | - 결제 완료 상태인데 재고/쿠폰이 복구됨- 잔액 차감은 남아 있음 (환불 안됨) |
| 동일 주문에 대한 주문 취소 요청 처리 → 결제 요청 처리 | - 주문은 이미 취소되었는데 결제는 완료됨- 무효 주문에 결제 정보가 남음 |

### ✅ 시나리오 결론

- 두 요청이 **모두 처리되면 정합성 문제가 발생**
- 반드시 **하나의 트랜잭션만 성공하고, 나머지는 실패 처리**되어야 함

### ✅ 테스트

- 동일 주문 대상 결제/주문 취소 프로세스 동시 진행
- 기대 결과
  - 최종 주문 상태가 payment_completed 일때
    - 재고: 기존 입력 값에서 변동 없어야 함
    - 쿠폰: 사용 상태여야 함
    - 잔액: 차감되어 있어야 함
  - 최종 주문 상태가 cancel_order 일때
    - 재고: 기존 입력 값에서 + 되어있어야 함
    - 쿠폰: 미사용 상태여야 함
    - 잔액: 기존 입력값에서 변동 없어야 함

---

## 🔐 Lock 전략

| 대상 | Lock 전략 | 처리 방식 |
| --- | --- | --- |
| `ORDER` | **낙관적 락 (Optimistic Lock)** | 충돌 시 하나의 요청만 성공 처리 → 나머지는 실패 처리 |

```java
@Lock(LockModeType.OPTIMISTIC)
Order findById(Long orderId);
```

- `ORDER` 테이블에 `version` 필드를 추가하고, update 시 해당 버전 조건으로 동시성 제어 수행

---

## 🧩 설계 근거

| 항목 | 설명 |
| --- | --- |
| 🔁 충돌 가능성 | 동일한 주문 건에 대해 결제와 취소가 **거의 동시에 요청될 수 있음** |
| 🚫 동시 처리 문제 | 두 요청이 모두 처리되면 **잔액, 재고, 쿠폰** 정합성 붕괴 |
| 🧩 처리 방식 차이 | 같은 테이블을 수정하지만, **비즈니스 로직이 상이하므로 상호 양립 불가** |
| 🔄 낙관적 락 적합성 | 충돌 시점에 하나의 요청만 update 성공, 나머지는 실패 처리 가능 |
| ✅ 실패 처리 허용 | 실패 시 재시도 또는 사용자 안내를 통해 처리 가능 |
| ⚖️ 비관적 락은 왜 아닌가? | 불필요한 락 경합, 락 대기, 트랜잭션 지연 가능성이 높음, 주문마다 단건 처리이므로 낙관적 락이 더 효율적 |

---

## ✅ 결론

- 결제와 주문 취소는 같은 주문 데이터를 갱신하지만, **논리적으로 상충되는 처리**를 수행한다.
- 이로 인해, 동시 요청 시 반드시 **하나의 트랜잭션만 성공 처리되어야 하며**, 나머지는 **낙관적 락 실패를 통해 에러 처리**되어야 한다.
- `ORDER` 테이블에 `version` 기반의 **낙관적 락을 적용**함으로써 정합성을 유지하고, **데이터 충돌에 대한 안전한 보호 장치**를 마련할 수 있다.

</details>